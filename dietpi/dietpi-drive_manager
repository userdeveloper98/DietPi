#!/bin/bash
{
	# ////////////////////////////////////
	# DietPi Drive Manager
	#
	#////////////////////////////////////
	# Created by Daniel Knight / daniel.knight@dietpi.com / dietpi.com
	#
	#////////////////////////////////////
	#
	# Info: Drive Manager for DietPi
	#
	# Usage:
	# 	  = Drive Manager
	#	1 = Selectadrive! Provides a list of available drive mount locations, with value on selection saved to: /tmp/dietpi-drive_manager_selmnt
	#	4 = Generates a new /etc/fstab based on current mounted locally drives (for use in PREP_SYSTEM_FOR_DIETPI.sh). NB: Resets /var/log to RAMLOG and /tmp enabled
	#
	#////////////////////////////////////

	#Import DietPi-Globals ---------------------------------------------------------------
	. /DietPi/dietpi/func/dietpi-globals
	G_PROGRAM_NAME='DietPi-Drive_Manager'
	G_CHECK_ROOT_USER
	G_INIT
	#Import DietPi-Globals ---------------------------------------------------------------

	#Custom exit trap extension, being called on every kind of script exit, err, int
	G_EXIT_CUSTOM(){ Destroy; }

	#Grab Input (valid interger)
	INPUT=0
	disable_error=1 G_CHECK_VALIDINT "$1" && INPUT=$1

	EXIT_CODE=0

	#Service control for script
	SERVICE_CONTROL=1

	#APT pre-req check flag, allows to check for required APT packages only once per session
	APT_CHECK=0

	#Return values
	FP_DRIVE_MANAGER_SELECTION='/tmp/dietpi-drive_manager_selmnt'

	#FP
	FP_TEMP_FSTAB='.fstab'

	#Drive data
	FP_ROOTFS_SOURCE=''
	FP_USERDATA_CURRENT=''
	FP_SWAPFILE_CURRENT=''

	INDEX_DRIVE_BEING_EDITED=0
	DRIVE_TARGET_BEING_EDITED=''

	FORMAT_GPT=1 # default GPT: https://github.com/Fourdee/DietPi/issues/531. 0=MBR
	FORMAT_FILESYSTEM_TYPE=0 #0=ext4 1=ntfs 2=fat32 3=hfs+ 4=btrfs 5=f2fs 6=exfat
	FORMAT_RECREATE_PARTITION_TABLE=1
	FORMAT_COMPLETED=0
	FORMAT_MODE=1 #0=drive 1=partition

	INDEX_INIT_CURRENT_DEVICE=-1
	Init_New_Device(){

		((INDEX_INIT_CURRENT_DEVICE++))

		aDRIVE_UUID[$INDEX_INIT_CURRENT_DEVICE]=''
		aDRIVE_PART_UUID[$INDEX_INIT_CURRENT_DEVICE]=''
		aDRIVE_MOUNT_SOURCE[$INDEX_INIT_CURRENT_DEVICE]=''
		aDRIVE_MOUNT_TARGET[$INDEX_INIT_CURRENT_DEVICE]=''
		aDRIVE_SOURCE_DEVICE[$INDEX_INIT_CURRENT_DEVICE]=''
		aDRIVE_FSTYPE[$INDEX_INIT_CURRENT_DEVICE]=''
		aDRIVE_SIZE_TOTAL[$INDEX_INIT_CURRENT_DEVICE]=''
		aDRIVE_SIZE_USED[$INDEX_INIT_CURRENT_DEVICE]=''
		aDRIVE_SIZE_PERCENTUSED[$INDEX_INIT_CURRENT_DEVICE]=''
		aDRIVE_SIZE_FREE[$INDEX_INIT_CURRENT_DEVICE]=''

		aDRIVE_ISFILESYSTEM[$INDEX_INIT_CURRENT_DEVICE]=0
		aDRIVE_ISMOUNTED[$INDEX_INIT_CURRENT_DEVICE]=0
		aDRIVE_ISREADONLY_CURRENTLY[$INDEX_INIT_CURRENT_DEVICE]=0
		aDRIVE_ISNETWORKED[$INDEX_INIT_CURRENT_DEVICE]=0
		aDRIVE_ISROM[$INDEX_INIT_CURRENT_DEVICE]=0
		aDRIVE_ISPARTITIONTABLE[$INDEX_INIT_CURRENT_DEVICE]=0

	}

	Destroy(){

		INDEX_INIT_CURRENT_DEVICE=-1

		#Delete []
		unset aDRIVE_UUID
		unset aDRIVE_PART_UUID
		unset aDRIVE_MOUNT_SOURCE
		unset aDRIVE_MOUNT_TARGET
		unset aDRIVE_SOURCE_DEVICE
		unset aDRIVE_FSTYPE
		unset aDRIVE_SIZE_TOTAL
		unset aDRIVE_SIZE_USED
		unset aDRIVE_SIZE_PERCENTUSED
		unset aDRIVE_SIZE_FREE

		unset aDRIVE_ISFILESYSTEM
		unset aDRIVE_ISMOUNTED
		unset aDRIVE_ISREADONLY_CURRENTLY
		unset aDRIVE_ISNETWORKED
		unset aDRIVE_ISROM
		unset aDRIVE_ISPARTITIONTABLE

	}

	Init_Drives_and_Refresh(){

		#---------------------------------------------------------------
		# Reset current index and delete arrays
		Destroy

		# Obtain actual user data location on disk (follows symlinks)
		FP_USERDATA_CURRENT="$(readlink -f $G_FP_DIETPI_USERDATA)"

		# Swapfile location
		FP_SWAPFILE_CURRENT="$(grep -m1 '^[[:blank:]]*AUTO_SETUP_SWAPFILE_LOCATION=' /DietPi/dietpi.txt | sed 's/^[^=]*=//')"

		# RootFS location
		FP_ROOTFS_SOURCE=$(findmnt / -o source -n)

		# Recreate FStab
		cp -a /etc/fstab $FP_TEMP_FSTAB

		# Grab current tmpfs entries
		local tmpfs_mounts=$(grep '^tmpfs[[:blank:]]' $FP_TEMP_FSTAB)

		# Grab current bind mounts
		local bind_mounts=$(grep '[[:blank:],]bind[[:blank:],]' $FP_TEMP_FSTAB)

		# Grab current swap
		local swap_mount=$(grep -m1 '[[:blank:]]swap[[:blank:]]' $FP_TEMP_FSTAB)

		# Grab current network mounts + creds
		local net_mounts_samba=$(grep '[[:blank:]]cifs[[:blank:]]' $FP_TEMP_FSTAB)
		local net_mounts_nfs=$(grep '[[:blank:]]nfs.*[[:blank:]]' $FP_TEMP_FSTAB)
		local net_mounts_ftp=$(grep '^curlftpfs' $FP_TEMP_FSTAB)

		# Force reset/clean fstab (PREP)
		if (( $INPUT == 4 )); then

			bind_mounts=''
			swap_mount=''
			net_mounts_samba=''
			net_mounts_nfs=''
			net_mounts_ftp=''

			local var_log_size=$(grep -m1 '^[[:blank:]]*AUTO_SETUP_RAMLOG_MAXSIZE=' /DietPi/dietpi.txt | sed 's/^[^=]*=//')
			tmpfs_mounts="tmpfs /tmp tmpfs defaults,noatime,nodev,nosuid,mode=1777 0 0
tmpfs /var/log tmpfs defaults,size=${var_log_size}m,noatime,nodev,nosuid,mode=1777 0 0
tmpfs /DietPi tmpfs defaults,size=10m,noatime,nodev,nosuid,mode=1777 0 0"

		fi

		echo "#-----------------------------------------------------------
#NETWORK
#-----------------------------------------------------------
#Please use DietPi-Drive_Manager to setup network mounts
$net_mounts_samba
$net_mounts_ftp
$net_mounts_nfs

#-----------------------------------------------------------
#TMPFS
#-----------------------------------------------------------
$tmpfs_mounts

#-----------------------------------------------------------
#MISC (bind)
#-----------------------------------------------------------
$bind_mounts

#-----------------------------------------------------------
#SWAPFILE
#-----------------------------------------------------------
$swap_mount

#-----------------------------------------------------------
#PHYSICAL DRIVES
#-----------------------------------------------------------" > $FP_TEMP_FSTAB

		# Detect mounted drives and add them to fstab
		G_DIETPI-NOTIFY 2 'Detecting drives, please wait...'
		df -Pha | tail -n +2 > .dietpi-drive_manager_df_tmp

		# - Remove items from list
		#	Bind: https://github.com/Fourdee/DietPi/issues/2013#issuecomment-416394374
		while read line
		do

			[[ $line ]] || continue

			# - Bind
			local input_bind_mount_source="$(awk '{print $1}' <<< $line)"
			local input_bind_mount_target="$(awk '{print $2}' <<< $line)"
			sed -i "\#[[:blank:]]$input_bind_mount_target#d" .dietpi-drive_manager_df_tmp
			sed -i "\#[[:blank:]]$input_bind_mount_source#d" .dietpi-drive_manager_df_tmp
			[[ $G_DEBUG == 1 ]] && G_DIETPI-NOTIFY 0 " - Detected bind mount and removed from df scrape: $input_bind_mount_source > $input_bind_mount_target"

		done <<< "$bind_mounts"

		# - Process final DF result
		while read line
		do

			[[ $line ]] || continue

			if [[ $(awk '{print $1}' <<< $line) =~ '/' ]]; then

				Init_New_Device

				aDRIVE_ISMOUNTED[$INDEX_INIT_CURRENT_DEVICE]=1
				aDRIVE_ISPARTITIONTABLE[$INDEX_INIT_CURRENT_DEVICE]=1
				aDRIVE_MOUNT_SOURCE[$INDEX_INIT_CURRENT_DEVICE]=$(awk '{print $1}' <<< $line)
				aDRIVE_SIZE_TOTAL[$INDEX_INIT_CURRENT_DEVICE]=$(awk '{print $2}' <<< $line)
				aDRIVE_SIZE_USED[$INDEX_INIT_CURRENT_DEVICE]=$(awk '{print $3}' <<< $line)
				aDRIVE_SIZE_FREE[$INDEX_INIT_CURRENT_DEVICE]=$(awk '{print $4}' <<< $line)
				aDRIVE_SIZE_PERCENTUSED[$INDEX_INIT_CURRENT_DEVICE]=$(awk '{print $5}' <<< $line)
				aDRIVE_MOUNT_TARGET[$INDEX_INIT_CURRENT_DEVICE]=$(awk '{print $6}' <<< $line)
				# - Workaround for /dev/root under RPi, force physical location
				[[ ${aDRIVE_MOUNT_TARGET[$INDEX_INIT_CURRENT_DEVICE]} == '/' ]] && aDRIVE_MOUNT_SOURCE[$INDEX_INIT_CURRENT_DEVICE]=$FP_ROOTFS_SOURCE

				aDRIVE_SOURCE_DEVICE[$INDEX_INIT_CURRENT_DEVICE]=$(Return_Drive_Without_Partitions ${aDRIVE_MOUNT_SOURCE[$INDEX_INIT_CURRENT_DEVICE]})
				aDRIVE_UUID[$INDEX_INIT_CURRENT_DEVICE]=$(blkid ${aDRIVE_MOUNT_SOURCE[$INDEX_INIT_CURRENT_DEVICE]} -s UUID -o value)
				aDRIVE_PART_UUID[$INDEX_INIT_CURRENT_DEVICE]=$(blkid ${aDRIVE_MOUNT_SOURCE[$INDEX_INIT_CURRENT_DEVICE]} -s PARTUUID -o value)

				# - Physical?
				if [[ -d '/sys/block/'${aDRIVE_SOURCE_DEVICE[$INDEX_INIT_CURRENT_DEVICE]} ]]; then

					aDRIVE_FSTYPE[$INDEX_INIT_CURRENT_DEVICE]=$(blkid ${aDRIVE_MOUNT_SOURCE[$INDEX_INIT_CURRENT_DEVICE]} -s TYPE -o value)
					[[ ${aDRIVE_FSTYPE[$INDEX_INIT_CURRENT_DEVICE]} ]] && aDRIVE_ISFILESYSTEM[$INDEX_INIT_CURRENT_DEVICE]=1

				# - Networked
				else

					aDRIVE_ISNETWORKED[$INDEX_INIT_CURRENT_DEVICE]=1
					aDRIVE_FSTYPE[$INDEX_INIT_CURRENT_DEVICE]='Net'
					aDRIVE_ISFILESYSTEM[$INDEX_INIT_CURRENT_DEVICE]=1

				fi

				G_DIETPI-NOTIFY 2 " - Detected mounted drive: ${aDRIVE_MOUNT_SOURCE[$INDEX_INIT_CURRENT_DEVICE]} > ${aDRIVE_MOUNT_TARGET[$INDEX_INIT_CURRENT_DEVICE]}"

				# - RO mounted?
				# - NB: We cant use -m1 for initial check as results can be:
				#	root@DietPi:~# cat /proc/mounts | grep ' / '
				#	rootfs / rootfs rw 0 0
				#	/dev/mmcblk0p2 / ext4 ro,noatime,discard,data=ordered 0 0
				if grep -q "[[:blank:]]${aDRIVE_MOUNT_TARGET[$INDEX_INIT_CURRENT_DEVICE]}[[:blank:]].*[[:blank:]]ro," /proc/mounts; then

					aDRIVE_ISREADONLY_CURRENTLY[$INDEX_INIT_CURRENT_DEVICE]=1

					# - RootFS RW check
					if [[ ${aDRIVE_MOUNT_TARGET[$INDEX_INIT_CURRENT_DEVICE]} == '/' ]]; then

						if G_WHIP_YESNO "RootFS is currently set to \"Read Only (R/O)\". $G_PROGRAM_NAME requires \"Read Write (R/W)\" access to function.\n\nWould you like to re-enable R/W access on RootFS?"; then

							G_RUN_CMD mount -v -o rw,remount ${aDRIVE_MOUNT_TARGET[$INDEX_INIT_CURRENT_DEVICE]}
							aDRIVE_ISREADONLY_CURRENTLY[$INDEX_INIT_CURRENT_DEVICE]=0
							G_DIETPI-NOTIFY 0 'Remounted RootFS with R/W access'

						else

							/DietPi/dietpi/dietpi-services start

							G_DIETPI-NOTIFY 1 "RootFS is currently set to R/O. $G_PROGRAM_NAME requires R/W access to function. Aborting..."
							G_DIETPI-NOTIFY 2 'Rerun "dietpi-drive_manager" to enable RootFS R/W access.'

							exit

						fi

					fi

				fi

				# - Add entry to fstab
				if [[ ${aDRIVE_UUID[$INDEX_INIT_CURRENT_DEVICE]} ]]; then

					local string_options=',rw'
					(( ${aDRIVE_ISREADONLY_CURRENTLY[$INDEX_INIT_CURRENT_DEVICE]} )) && string_options=',ro'

					# - UUID or PARTUUID entry?
					local dev_entry="UUID=${aDRIVE_UUID[$INDEX_INIT_CURRENT_DEVICE]}"
					if (( $G_HW_MODEL < 10 )) && [[ ${aDRIVE_MOUNT_TARGET[$INDEX_INIT_CURRENT_DEVICE]} =~ ^/(boot)?$ ]]; then

						dev_entry="PARTUUID=${aDRIVE_PART_UUID[$INDEX_INIT_CURRENT_DEVICE]}"

					fi

					# - Non-RootFS flags
					#	fsck flag for root device, to allow check on reboot
					#	nofail: Allow boot to continue, if mount fails
					#	x-systemd.automount: [ 1166.110202] systemd-fstab-generator[3512]: Ignoring automount option for root device
					local fsck_flag=1
					if [[ ${aDRIVE_MOUNT_TARGET[$INDEX_INIT_CURRENT_DEVICE]} != '/' ]]; then

						string_options+=',nofail,x-systemd.automount'
						fsck_flag=0

					fi

					# - Additional options for fstype specific items
					#	NFTS: Enable POSIX permissions for NTFS
					if [[ ${aDRIVE_FSTYPE[$INDEX_INIT_CURRENT_DEVICE]} == 'ntfs' ]]; then

						string_options+=',permissions'

					fi

					echo "$dev_entry ${aDRIVE_MOUNT_TARGET[$INDEX_INIT_CURRENT_DEVICE]} auto defaults,noatime$string_options 0 $fsck_flag" >> $FP_TEMP_FSTAB

				fi

			fi

		done < .dietpi-drive_manager_df_tmp
		rm .dietpi-drive_manager_df_tmp

		# - Check blkid for unmounted drives, if drive is not mounted, add entry as disabled mount
		blkid -o device > .dietpi-drive_manager_blkid_tmp
		while read line
		do

			[[ $line ]] || continue

			for ((i=0; i<${#aDRIVE_MOUNT_SOURCE[@]}; i++))
			do

				[[ ${aDRIVE_MOUNT_SOURCE[$i]} == $line ]] && break

				# - New unmounted drive found on system, add entry to fstab
				#	Must have a valid UUID! (this excludes /dev/mmcblk0)
				if (( $i == ${#aDRIVE_MOUNT_SOURCE[@]} - 1 )); then

					local uuid=$(blkid $line -s UUID -o value)
					[[ $uuid ]] || break

					G_DIETPI-NOTIFY 2 " - Detected unmounted drive: $line"

					Init_New_Device

					aDRIVE_UUID[$INDEX_INIT_CURRENT_DEVICE]=$uuid
					aDRIVE_ISPARTITIONTABLE[$INDEX_INIT_CURRENT_DEVICE]=1
					aDRIVE_MOUNT_SOURCE[$INDEX_INIT_CURRENT_DEVICE]=$line
					aDRIVE_MOUNT_TARGET[$INDEX_INIT_CURRENT_DEVICE]="/mnt/${aDRIVE_UUID[$INDEX_INIT_CURRENT_DEVICE]}"
					aDRIVE_SOURCE_DEVICE[$INDEX_INIT_CURRENT_DEVICE]=$(Return_Drive_Without_Partitions ${aDRIVE_MOUNT_SOURCE[$INDEX_INIT_CURRENT_DEVICE]})

					aDRIVE_PART_UUID[$INDEX_INIT_CURRENT_DEVICE]=$(blkid ${aDRIVE_MOUNT_SOURCE[$INDEX_INIT_CURRENT_DEVICE]} -s PARTUUID -o value)
					aDRIVE_FSTYPE[$INDEX_INIT_CURRENT_DEVICE]=$(blkid ${aDRIVE_MOUNT_SOURCE[$INDEX_INIT_CURRENT_DEVICE]} -s TYPE -o value)
					[[ ${aDRIVE_FSTYPE[$INDEX_INIT_CURRENT_DEVICE]} ]] && aDRIVE_ISFILESYSTEM[$INDEX_INIT_CURRENT_DEVICE]=1

					echo "#UUID=${aDRIVE_UUID[$INDEX_INIT_CURRENT_DEVICE]} ${aDRIVE_MOUNT_TARGET[$INDEX_INIT_CURRENT_DEVICE]} auto defaults,noatime,rw,nofail,x-systemd.automount 0 0" >> $FP_TEMP_FSTAB

				fi

			done

		done < .dietpi-drive_manager_blkid_tmp
		rm .dietpi-drive_manager_blkid_tmp

		# - Find drives that have no partitions
		#	Exclude mtdblock devices: https://github.com/Fourdee/DietPi/issues/2067#issuecomment-422400520
		lsblk -nro NAME | sed '/^mtdblock[0-9]/d' > .dietpi-drive_manager_lsblk_tmp
		while read line
		do

			[[ $line ]] || continue

			# - Exclude drives already found
			for i in ${!aDRIVE_MOUNT_SOURCE[@]}
			do

				[[ $line == ${aDRIVE_SOURCE_DEVICE[$i]}* ]] && continue 2

			done

			G_DIETPI-NOTIFY 2 " - Detected drive with no partitions: $line"

			Init_New_Device

			aDRIVE_MOUNT_SOURCE[$INDEX_INIT_CURRENT_DEVICE]="/dev/$line"
			aDRIVE_MOUNT_TARGET[$INDEX_INIT_CURRENT_DEVICE]="/tmp/$line"
			aDRIVE_SOURCE_DEVICE[$INDEX_INIT_CURRENT_DEVICE]=$line

		done < .dietpi-drive_manager_lsblk_tmp
		rm .dietpi-drive_manager_lsblk_tmp

		# - Set required global flags and deps for all drives found
		for i in ${!aDRIVE_MOUNT_SOURCE[@]}
		do

			# - Detect and set ROM drives
			[[ ${aDRIVE_MOUNT_SOURCE[$i]} == '/dev/sr'* ]] && aDRIVE_ISROM[$i]=1

			# - Collect required APT packages for FS R/W access
			if [[ ${aDRIVE_FSTYPE[$i]} == 'ntfs' ]]; then

				local need_ntfs='ntfs-3g'

			elif [[ ${aDRIVE_FSTYPE[$i]} =~ 'hfs' ]]; then

				local need_hfs='hfsplus'

			fi

		done

		# - Debug drive detection, exit after first init
		if [[ $G_DEBUG == 1 ]]; then

			G_DIETPI-NOTIFY 0 'DEBUG INFO:'
			for i in ${!aDRIVE_MOUNT_SOURCE[@]}
			do

				G_DIETPI-NOTIFY 0 "Index=$i
aDRIVE_UUID ${aDRIVE_UUID[$i]}
aDRIVE_PART_UUID ${aDRIVE_PART_UUID[$i]}
aDRIVE_MOUNT_SOURCE ${aDRIVE_MOUNT_SOURCE[$i]}
aDRIVE_MOUNT_TARGET ${aDRIVE_MOUNT_TARGET[$i]}
aDRIVE_SOURCE_DEVICE ${aDRIVE_SOURCE_DEVICE[$i]}
aDRIVE_FSTYPE ${aDRIVE_FSTYPE[$i]}
aDRIVE_SIZE_TOTAL ${aDRIVE_SIZE_TOTAL[$i]}
aDRIVE_SIZE_USED ${aDRIVE_SIZE_USED[$i]}
aDRIVE_SIZE_PERCENTUSED ${aDRIVE_SIZE_PERCENTUSED[$i]}
aDRIVE_SIZE_FREE ${aDRIVE_SIZE_FREE[$i]}
aDRIVE_ISFILESYSTEM ${aDRIVE_ISFILESYSTEM[$i]}
aDRIVE_ISMOUNTED ${aDRIVE_ISMOUNTED[$i]}
aDRIVE_ISREADONLY_CURRENTLY ${aDRIVE_ISREADONLY_CURRENTLY[$i]}
aDRIVE_ISNETWORKED ${aDRIVE_ISNETWORKED[$i]}
aDRIVE_ISROM ${aDRIVE_ISROM[$i]}
aDRIVE_ISPARTITIONTABLE ${aDRIVE_ISPARTITIONTABLE[$i]}
"

			done

			exit

		fi

		# - Remove x-systemd.automount if not supported by kernel: https://github.com/Fourdee/DietPi/issues/1607#issuecomment-372030565
		if ! modprobe autofs4 --dry-run &> /dev/null; then

			sed -i 's/,x-systemd.automount//g' $FP_TEMP_FSTAB
			G_DIETPI-NOTIFY 2 'autofs4 module not available in kernel, x-systemd.automount has been disabled'

		fi

		# - Find the drive we are to edit, then set its index (this is due to array list total being not constant)
		if [[ $DRIVE_TARGET_BEING_EDITED ]]; then

			for i in ${!aDRIVE_MOUNT_SOURCE[@]}
			do

				if [[ $DRIVE_TARGET_BEING_EDITED == ${aDRIVE_MOUNT_TARGET[$i]} ]]; then

					INDEX_DRIVE_BEING_EDITED=$i
					[[ $G_DEBUG == 1 ]] && echo "[DEBUG$i] EDIT | ${aDRIVE_MOUNT_TARGET[$INDEX_DRIVE_BEING_EDITED]} | ${aDRIVE_MOUNT_SOURCE[$INDEX_DRIVE_BEING_EDITED]} | ${aDRIVE_SOURCE_DEVICE[$INDEX_DRIVE_BEING_EDITED]}"
					break

				fi

			done

		fi

		cp -a $FP_TEMP_FSTAB /etc/fstab
		systemctl daemon-reload

		rm $FP_TEMP_FSTAB

		# - Install required APT packages for FS R/W access
		(( ! $APT_CHECK )) && [[ $need_ntfs || $need_hfs ]] && G_AG_CHECK_INSTALL_PREREQ $need_ntfs $need_hfs && APT_CHECK=1

		sync
		mount -a

	}

	Rm_Empty_Dir(){

		local fp_dir="$1"
		if [[ -d $fp_dir && ! $(ls -A $fp_dir) ]]; then

			rm -R "$fp_dir"
			G_DIETPI-NOTIFY 2 "Removed empty directory: $fp_dir"

		else

			G_DIETPI-NOTIFY 2 "Not removing directory, as it contains data: $fp_dir"

		fi

	}

	Return_Drive_Without_Partitions(){

		#$1 = dev source
		local drive=${1#/dev/}
		if [[ $drive == [sh]d* ]]; then

			echo ${drive%[0-9]}

		#MMC/NVMe
		else

			echo ${drive%p[0-9]}

		fi

	}

	#$1=source $2=target
	Mount_Drive(){

		local source=$1
		local target=$2
		local apply_mount=1

		G_WHIP_DEFAULT_ITEM=$target
		G_WHIP_INPUTBOX "Please enter the target path, this device will mount to.\n - Default and recommended = $target\n\nNB: The path must start with /mnt/ and be unique. Spaces will be converted automatically to underscores (_)."
		if (( $? == 0 )); then

			if [[ $G_WHIP_RETURNED_VALUE == '/mnt/'* ]]; then

				# - replace spaces with underscores
				target="${G_WHIP_RETURNED_VALUE//[[:space:]]/_}"

			else

				G_WHIP_MSG "Invalid mount target location:\n - $G_WHIP_RETURNED_VALUE\n\nThe drive will now be mounted to:\n - $target"

			fi

		fi

		if [[ -d $target ]]; then

			if [[ $(ls -A $target) ]]; then

				G_WHIP_MSG "Error:\n\nThe mount target directory already exists, and, contains data:\n - $target\n\nPlease retry, using a unique mount target location."
				apply_mount=0

			else

				G_WHIP_YESNO "Warning:\n\nThe mount target directory already exists, however, it does not contain any files or data at this time:\n - $target\n\nDo you wish to ignore this warning, and, mount the drive regardless?"
				(( $? )) && apply_mount=0

			fi

		fi

		if (( $apply_mount )); then

			# - Additional mount options
			local additional_options=''
			#	fstype specific items
			if [[ ${aDRIVE_FSTYPE[$INDEX_DRIVE_BEING_EDITED]} == 'ntfs' ]]; then

				additional_options='-o permissions'

			fi

			G_DIETPI-NOTIFY 2 "Creating mount folder for $target"
			mkdir -p $target
			G_ERROR_HANDLER_INFO_ONLY=1 G_RUN_CMD mount $source $target $additional_options
			DRIVE_TARGET_BEING_EDITED="$target"

		fi

	}

	#$=target
	Unmount_Drive(){

		local target=$1

		G_ERROR_HANDLER_INFO_ONLY=1 G_RUN_CMD umount $target
		if (( $? == 0 )); then

			sed -i "\#[[:space:]]$target[[:space:]]#d" /etc/fstab #Only needed for networked drives currently...
			Rm_Empty_Dir "$target"

		fi

	}

	Resize_FS(){

		if [[ ${aDRIVE_MOUNT_TARGET[$INDEX_DRIVE_BEING_EDITED]} == '/' ]]; then

			systemctl unmask dietpi-fs_partition_resize
			G_RUN_CMD systemctl enable dietpi-fs_partition_resize

			G_WHIP_YESNO 'RootFS resize will occur on next reboot.\n\nWould you like to reboot the system now?' && reboot

		else

			G_ERROR_HANDLER_INFO_ONLY=1 G_RUN_CMD resize2fs ${aDRIVE_MOUNT_SOURCE[$INDEX_DRIVE_BEING_EDITED]}

		fi

	}

	Run_Format(){

		local info_format_fs_type=''
		local info_format_type_output='Drive format' #used in complete message
		local text_desc=''

		# - No partition table, force drive wipe
		(( ${aDRIVE_ISPARTITIONTABLE[$INDEX_DRIVE_BEING_EDITED]} )) || FORMAT_MODE=0

		if (( $FORMAT_MODE == 0 )); then

			text_desc=" - /dev/${aDRIVE_SOURCE_DEVICE[$INDEX_DRIVE_BEING_EDITED]}\n - UUID=${aDRIVE_UUID[$INDEX_DRIVE_BEING_EDITED]}\n - Partition table: $partition_table_text\n - Filesystem type: $format_type_text\n\nALL DATA and PARTITIONS on this drive will be DELETED.\nDo you wish to continue?"

		elif (( $FORMAT_MODE == 1 )); then

			text_desc=" - ${aDRIVE_MOUNT_SOURCE[$INDEX_DRIVE_BEING_EDITED]}\n - UUID=${aDRIVE_UUID[$INDEX_DRIVE_BEING_EDITED]}\n - Filesystem type: $format_type_text\n\nALL DATA on this PARTITION will be DELETED.\nDo you wish to continue?"
		fi

		if G_WHIP_YESNO "Ready to format:\n$text_desc"; then

			# - Drive format
			#	Create a new partition table
			if (( $FORMAT_MODE == 0 )); then

				# - Umount and Zero All Partitions on device
				for i in {1..9}
				do

					# - Obtain partition location to wipe
					#	mmcblkXp1/nvmeXn1p1
					local fp_target_partition="/dev/${aDRIVE_SOURCE_DEVICE[$INDEX_DRIVE_BEING_EDITED]}p$i"
					#	h/sdX1
					if [[ ${aDRIVE_SOURCE_DEVICE[$INDEX_DRIVE_BEING_EDITED]} == [sh]d[a-z]* ]]; then

						fp_target_partition="/dev/${aDRIVE_SOURCE_DEVICE[$INDEX_DRIVE_BEING_EDITED]}$i"

					fi

					if [[ -b $fp_target_partition ]]; then

						umount $fp_target_partition
						G_DIETPI-NOTIFY 2 "Writing zero's to partition $fp_target_partition"
						G_RUN_CMD dd if=/dev/zero of=$fp_target_partition bs=4K count=10 #Partition wipe (if it has one), must be done 1st, else blkid still reports UUID's etc

					fi

				done

				# - Clear Partition table from device
				G_DIETPI-NOTIFY 2 "Writing zero's to partition table /dev/${aDRIVE_SOURCE_DEVICE[$INDEX_DRIVE_BEING_EDITED]}"
				G_RUN_CMD dd if=/dev/zero of=/dev/${aDRIVE_SOURCE_DEVICE[$INDEX_DRIVE_BEING_EDITED]} bs=4K count=1337 #Block device wipe

				# - Create partition table type
				local parition_table_type='gpt'
				(( $FORMAT_GPT )) || parition_table_type='msdos'

				G_DIETPI-NOTIFY 2 "Creating partition table, with target type: $parition_table_type"

				G_RUN_CMD parted -s /dev/${aDRIVE_SOURCE_DEVICE[$INDEX_DRIVE_BEING_EDITED]} mklabel $parition_table_type
				G_RUN_CMD parted -a optimal /dev/${aDRIVE_SOURCE_DEVICE[$INDEX_DRIVE_BEING_EDITED]} mkpart primary 0% 100%
				partprobe /dev/${aDRIVE_SOURCE_DEVICE[$INDEX_DRIVE_BEING_EDITED]}

				sleep 1 # due to systemd automount, wait for it.
				umount ${aDRIVE_MOUNT_SOURCE[$INDEX_DRIVE_BEING_EDITED]}

				# - Generate new aDRIVE_MOUNT_SOURCE location to use
				#	mmcblkXp1/nvmeXn1p1
				aDRIVE_MOUNT_SOURCE[$INDEX_DRIVE_BEING_EDITED]="/dev/${aDRIVE_SOURCE_DEVICE[$INDEX_DRIVE_BEING_EDITED]}p1"
				#	h/sdX1
				if [[ ${aDRIVE_SOURCE_DEVICE[$INDEX_DRIVE_BEING_EDITED]} == [sh]d[a-z]* ]]; then

					aDRIVE_MOUNT_SOURCE[$INDEX_DRIVE_BEING_EDITED]="/dev/${aDRIVE_SOURCE_DEVICE[$INDEX_DRIVE_BEING_EDITED]}1"

				#	NanoPC-T4 + NVMe special: https://github.com/Fourdee/DietPi/issues/2102#issue-366001513
				elif (( $G_HW_MODEL == 68 )) && [[ ${aDRIVE_SOURCE_DEVICE[$INDEX_DRIVE_BEING_EDITED]} == nvme* ]]; then

					aDRIVE_MOUNT_SOURCE[$INDEX_DRIVE_BEING_EDITED]="/dev/${aDRIVE_SOURCE_DEVICE[$INDEX_DRIVE_BEING_EDITED]}p6"

				fi

			elif (( $FORMAT_MODE == 1 )); then

				info_format_type_output='Single partition format'

				# - Unmount partition
				umount ${aDRIVE_MOUNT_SOURCE[$INDEX_DRIVE_BEING_EDITED]}

				# - Clear partition from device
				G_DIETPI-NOTIFY 2 "Writing zero's to partition ${aDRIVE_MOUNT_SOURCE[$INDEX_DRIVE_BEING_EDITED]}"
				G_RUN_CMD dd if=/dev/zero of=${aDRIVE_MOUNT_SOURCE[$INDEX_DRIVE_BEING_EDITED]} bs=4K count=1337

			fi

			# - Format ext4
			if (( $FORMAT_FILESYSTEM_TYPE == 0 )); then

				# force
				info_format_fs_type='EXT4'
				G_RUN_CMD mkfs.ext4 -F -m 0 ${aDRIVE_MOUNT_SOURCE[$INDEX_DRIVE_BEING_EDITED]}
				resize2fs ${aDRIVE_MOUNT_SOURCE[$INDEX_DRIVE_BEING_EDITED]}

			# - Format NTFS
			elif (( $FORMAT_FILESYSTEM_TYPE == 1 )); then

				# fast format / no indexing / force
				info_format_fs_type='NTFS'
				G_RUN_CMD mkfs.ntfs -f -I -F ${aDRIVE_MOUNT_SOURCE[$INDEX_DRIVE_BEING_EDITED]}

			# - Format FAT32
			elif (( $FORMAT_FILESYSTEM_TYPE == 2 )); then

				#  use 1 parition on whole device
				info_format_fs_type='FAT'
				G_RUN_CMD mkfs.vfat -I ${aDRIVE_MOUNT_SOURCE[$INDEX_DRIVE_BEING_EDITED]}

			# - Format HFS+
			elif (( $FORMAT_FILESYSTEM_TYPE == 3 )); then

				info_format_fs_type='HFS+'
				G_RUN_CMD mkfs.hfsplus ${aDRIVE_MOUNT_SOURCE[$INDEX_DRIVE_BEING_EDITED]}

			# - Format btrfs
			elif (( $FORMAT_FILESYSTEM_TYPE == 4 )); then

				# force
				info_format_fs_type='BTRFS'
				G_RUN_CMD mkfs.btrfs -f ${aDRIVE_MOUNT_SOURCE[$INDEX_DRIVE_BEING_EDITED]}

			# - Format f2fs
			elif (( $FORMAT_FILESYSTEM_TYPE == 5 )); then

				info_format_fs_type='F2FS'
				G_RUN_CMD mkfs.f2fs ${aDRIVE_MOUNT_SOURCE[$INDEX_DRIVE_BEING_EDITED]}

			# - Format exFAT
			elif (( $FORMAT_FILESYSTEM_TYPE == 6 )); then

				info_format_fs_type='exFAT'
				G_RUN_CMD mkfs.exfat ${aDRIVE_MOUNT_SOURCE[$INDEX_DRIVE_BEING_EDITED]}

			fi

			G_DIETPI-NOTIFY 0 "Created $info_format_fs_type filesystem: ${aDRIVE_MOUNT_SOURCE[$INDEX_DRIVE_BEING_EDITED]}"
			FORMAT_COMPLETED=1
			local format_previous_mount_source=${aDRIVE_MOUNT_SOURCE[$INDEX_DRIVE_BEING_EDITED]}
			local format_previous_mount_target=${aDRIVE_MOUNT_TARGET[$INDEX_DRIVE_BEING_EDITED]}

			Init_Drives_and_Refresh

			local format_new_uuid=$(blkid $format_previous_mount_source -s UUID -o value)
			[[ -e $format_previous_mount_target ]] && rm -R $format_previous_mount_target

			# - Automatically mount it
			DRIVE_TARGET_BEING_EDITED="/mnt/$format_new_uuid"
			Mount_Drive $format_previous_mount_source $DRIVE_TARGET_BEING_EDITED

			Init_Drives_and_Refresh

			G_WHIP_MSG "Format completed:\n
 - Format Type           : $info_format_type_output
 - Filesystem Type       : $info_format_fs_type
 - Previous Mount Source : $format_previous_mount_target
 - New Mount Source      : ${aDRIVE_MOUNT_TARGET[$INDEX_DRIVE_BEING_EDITED]}"

		fi

	}

	RootFS_Move(){

		/DietPi/dietpi/dietpi-services stop

		# - install rsync
		G_AG_CHECK_INSTALL_PREREQ rsync

		#Remove previous fstab entry and mount location
		cp -a /etc/fstab /etc/fstab.bak #incase of Rsync fail

		#	Remove automatic entry for new uuid
		sed -i "\@[[:space:]]${aDRIVE_MOUNT_TARGET[$INDEX_DRIVE_BEING_EDITED]}[[:space:]]@d" /etc/fstab

		#	Add new rootfs entry
		local dev_entry="UUID=${aDRIVE_UUID[$INDEX_DRIVE_BEING_EDITED]}"
		(( $G_HW_MODEL < 10 )) && dev_entry="PARTUUID=${aDRIVE_PART_UUID[$INDEX_DRIVE_BEING_EDITED]}"
		sed -i "\@[[:space:]]/[[:space:]]auto@c $dev_entry / auto defaults,noatime 0 1" /etc/fstab

		# - Disable Swap
		/DietPi/dietpi/func/dietpi-set_dphys-swapfile 0

		rsync -aHv --delete --exclude '/boot/*' --exclude '/lost+found/' --exclude '/mnt/*' --exclude ${aDRIVE_MOUNT_TARGET[$INDEX_DRIVE_BEING_EDITED]}/ --exclude '/sys/*' --exclude '/proc/*' / "${aDRIVE_MOUNT_TARGET[$INDEX_DRIVE_BEING_EDITED]}"/
		if (( $? )); then

			G_DIETPI-NOTIFY 1 'Rsync has failed, RootFS transfer has been aborted.'
			#	revert FSTAB changes
			cp -a /etc/fstab.bak /etc/fstab

			exit

		fi

		# - Recreate swap
		# /DietPi/dietpi/func/dietpi-set_dphys-swapfile 1 ${aDRIVE_MOUNT_TARGET[$INDEX_DRIVE_BEING_EDITED]}/var/swap/.swap
		#	Manually update location
		# sed -i "/^[[:blank:]]*AUTO_SETUP_SWAPFILE_LOCATION=/c\AUTO_SETUP_SWAPFILE_LOCATION=/var/swap" /DietPi/dietpi.txt

		#RPi | cmdline.txt
		if (( $G_HW_MODEL < 10 )); then

			#	find current root= and replace
			local rootfs_current=$(awk '{for(i=1;i<=NF;i++) {print $i} }' /boot/cmdline.txt | grep -m1 'root=')
			sed -i "s#$rootfs_current#root=PARTUUID=${aDRIVE_PART_UUID[$INDEX_DRIVE_BEING_EDITED]}#g" /boot/cmdline.txt

			#	Add root delay
			grep -qi '[[:space:]]rootdelay=' /boot/cmdline.txt || sed -i "s#console=tty1#console=tty1 rootdelay=10#g" /boot/cmdline.txt

			#	set FS type
			local rootfstype_current=$(awk '{for(i=1;i<=NF;i++) {print $i} }' /boot/cmdline.txt | grep -m1 'rootfstype=')
			sed -i "s#$rootfstype_current#rootfstype=${aDRIVE_FSTYPE[$INDEX_DRIVE_BEING_EDITED]}#g" /boot/cmdline.txt

		#C1/C2/XU4 | /DietPi/boot.ini
		elif (( $G_HW_MODEL == 10 || $G_HW_MODEL == 11 || $G_HW_MODEL == 12 )); then

			#	find current root= to replace
			local rootfs_current=$(awk '{for(i=1;i<=NF;i++) {print $i} }' /DietPi/boot.ini | grep -m1 'root=' | sed 's/\"//')
			sed -i "s#$rootfs_current#root=UUID=${aDRIVE_UUID[$INDEX_DRIVE_BEING_EDITED]}#g" /DietPi/boot.ini

		fi

		systemctl daemon-reload
		sync

		G_WHIP_MSG 'RootFS transfer completed. Press enter to reboot system.'
		reboot

	}

	Toggle_WriteMode(){

		local exit_status=0
		local message_result=0

		if (( ${aDRIVE_ISREADONLY_CURRENTLY[$INDEX_DRIVE_BEING_EDITED]} )); then

			message_result=$(mount -v -o rw,remount ${aDRIVE_MOUNT_SOURCE[$INDEX_DRIVE_BEING_EDITED]} 2>&1)
			exit_status=$?

		else

			message_result=$(mount -v -o ro,remount ${aDRIVE_MOUNT_SOURCE[$INDEX_DRIVE_BEING_EDITED]} 2>&1)
			exit_status=$?

		fi

		(( $exit_status )) && G_WHIP_MSG "Failed to apply:\n\nDue to:\n - $message_result"

	}

	TARGETMENUID=0
	MENU_LASTITEM=''

	Menu_Main_Drive_Manager(){

		#Generate menu
		G_WHIP_MENU_ARRAY=()

		# - Create a nice category list, to match items to their block device (eg: mmcblk0)
		local acategory_list=()
		for i in ${!aDRIVE_MOUNT_SOURCE[@]}
		do

			local new_cat=1

			for j in ${!acategory_list[@]}
			do

				if [[ ${aDRIVE_SOURCE_DEVICE[$i]} == ${acategory_list[$j]} ]]; then

					new_cat=0
					break

				fi

			done

			# - add
			(( $new_cat )) && acategory_list+=( ${aDRIVE_SOURCE_DEVICE[$i]} )

		done

		#List all available drives, if no drive found, list info for user.
		local drive_available=0
		for i in ${!acategory_list[@]}
		do

			drive_available=1
			G_WHIP_MENU_ARRAY+=('' "●─ ${acategory_list[$i]} ")

			for j in ${!aDRIVE_MOUNT_SOURCE[@]}
			do

				if [[ ${aDRIVE_SOURCE_DEVICE[$j]} == ${acategory_list[$i]} ]]; then

					local string_fstype=${aDRIVE_FSTYPE[$j]}
					(( ${aDRIVE_ISNETWORKED[$j]} )) && string_fstype='Net'

					#Drive is fully mounted:
					if (( ${aDRIVE_ISMOUNTED[$j]} )); then

						G_WHIP_MENU_ARRAY+=("${aDRIVE_MOUNT_TARGET[$j]}" ": ${aDRIVE_MOUNT_SOURCE[$j]} | $string_fstype | Capacity: ${aDRIVE_SIZE_TOTAL[$j]} | Used: ${aDRIVE_SIZE_USED[$j]} (${aDRIVE_SIZE_PERCENTUSED[$j]})")

					#Not mounted, why?
					else

						# - Drive has no FS:
						if (( ! ${aDRIVE_ISFILESYSTEM[$j]} )); then

							# - ROM device with no ROM attached
							if (( ${aDRIVE_ISROM[$j]} )); then

								G_WHIP_MENU_ARRAY+=("${aDRIVE_MOUNT_TARGET[$j]}" ": ${aDRIVE_MOUNT_SOURCE[$j]} | Please insert media into the ROM device")

							else

								G_WHIP_MENU_ARRAY+=("${aDRIVE_MOUNT_TARGET[$j]}" ": ${aDRIVE_MOUNT_SOURCE[$j]} | No filesystem / format required")

							fi

						# - Drive is not mounted:
						else

							G_WHIP_MENU_ARRAY+=("${aDRIVE_MOUNT_TARGET[$j]}" ": ${aDRIVE_MOUNT_SOURCE[$j]} | $string_fstype | Not mounted")

						fi

					fi

				fi

			done

		done

		unset acategory_list

		G_WHIP_MENU_ARRAY+=('' '●─ Global Options')

		G_WHIP_MENU_ARRAY+=('Idle Spindown' ': Set a global idle duration, before drives power down')

		G_WHIP_MENU_ARRAY+=('' '●─ Add / Refresh Drives')

		G_WHIP_MENU_ARRAY+=('Add network drive' ': Select to mount networked drives')

		if (( $drive_available )); then

			G_WHIP_MENU_ARRAY+=('Refresh' ': Scan for recently added/removed drives')

		else

			G_WHIP_MENU_ARRAY+=('Refresh' ': No drives found. Insert a drive and select this option')

		fi

		# - User data
		local userdata_location_text="RootFS ($FP_USERDATA_CURRENT)"
		[[ $FP_USERDATA_CURRENT == $G_FP_DIETPI_USERDATA ]] || userdata_location_text="$FP_USERDATA_CURRENT"

		G_WHIP_DEFAULT_ITEM="$MENU_LASTITEM"
		G_WHIP_BUTTON_CANCEL_TEXT='Exit'
		if G_WHIP_MENU "Please select a drive to see available options.\n - User data location: $userdata_location_text"; then

			MENU_LASTITEM="$G_WHIP_RETURNED_VALUE"

			# - Refresh
			if [[ $G_WHIP_RETURNED_VALUE == 'Refresh' ]]; then

				Init_Drives_and_Refresh

			elif [[ $G_WHIP_RETURNED_VALUE == 'Add network drive' ]]; then

				TARGETMENUID=3

			elif [[ $G_WHIP_RETURNED_VALUE == 'Idle Spindown' ]]; then

				local apm=127

				G_WHIP_MENU_ARRAY=('0' ': Disabled')

				local time_info=0
				for i in {1..240}
				do

					time_info=$(( $i * 5 ))

					G_WHIP_MENU_ARRAY+=($i ": $time_info Seconds")

				done

				for i in {241..251}
				do

					time_info=$(( ( $i - 240 ) * 30 ))

					G_WHIP_MENU_ARRAY+=($i ": $time_info Minutes")

				done

				G_WHIP_DEFAULT_ITEM=241
				if G_WHIP_MENU "Please select a idle duration of time, before each drive is powered down:
 - This will be applied to all drives on the system
 - Not all drives support the feature of 'hdparm' and visa versa. End results may vary.
 - You can check status with 'hdparm -C /dev/sd*'"; then

					> /etc/hdparm.conf
					for i in ${!aDRIVE_MOUNT_SOURCE[@]}
					do

						if (( ! ${aDRIVE_ISNETWORKED[$i]} )) && ! grep -q "^/dev/${aDRIVE_SOURCE_DEVICE[$i]}$" /etc/hdparm.conf; then

							G_ERROR_HANDLER_NO_FAIL=1 G_RUN_CMD hdparm -B $apm /dev/${aDRIVE_SOURCE_DEVICE[$i]}
							G_ERROR_HANDLER_NO_FAIL=1 G_RUN_CMD hdparm -S $G_WHIP_RETURNED_VALUE /dev/${aDRIVE_SOURCE_DEVICE[$i]}

							echo "/dev/${aDRIVE_SOURCE_DEVICE[$i]}
{
   apm = $apm
   spindown_time = $G_WHIP_RETURNED_VALUE
}" >> /etc/hdparm.conf

						fi

					done

				fi

			# - Edit drive
			elif [[ $G_WHIP_RETURNED_VALUE ]]; then

				TARGETMENUID=1
				DRIVE_TARGET_BEING_EDITED="$G_WHIP_RETURNED_VALUE"
				Init_Drives_and_Refresh

			fi

		#Exit
		else

			Menu_Exit

		fi

	}

	Notification(){

		local input=$1

		if (( $1 == 0 )); then

			G_WHIP_MSG "Failed\n\nThe DietPi user data is currently located on this drive:\n - $FP_USERDATA_CURRENT\n\nThe requested option for this drive is not currently possible.\n\nPlease move your user data elsewhere, before trying again:\nhttps://dietpi.com/phpbb/viewtopic.php?f=8&t=478"

		elif (( $1 == 1 )); then

			G_WHIP_MSG "Failed\n\nThe DietPi swapfile is currently located on this drive:\n - $FP_SWAPFILE_CURRENT\n\nThe requested option for this drive is not currently possible.\n\nPlease move the swapfile elsewhere, before trying again."

		fi

	}

	Menu_Drive_Manager_Edit_Drive(){

		#Return to this menu
		TARGETMENUID=1

		local partition_contains_userdata=0
		local partition_contains_swapfile=0

		#Generate menu
		local whiptail_desc=''
		G_WHIP_MENU_ARRAY=()

		whiptail_desc="Mount target: ${aDRIVE_MOUNT_TARGET[$INDEX_DRIVE_BEING_EDITED]}"
		whiptail_desc+="\nMount source: ${aDRIVE_MOUNT_SOURCE[$INDEX_DRIVE_BEING_EDITED]}"

		#No filesystem
		if (( ! ${aDRIVE_ISFILESYSTEM[$INDEX_DRIVE_BEING_EDITED]} )); then

			if (( ${aDRIVE_ISROM[$INDEX_DRIVE_BEING_EDITED]} )); then

				whiptail_desc+='\nStatus:       No media found, please insert media into the ROM device'
				G_WHIP_MENU_ARRAY+=('Refresh' ': No media found, please insert media into the ROM device')

			else

				whiptail_desc+='\nStatus:       Drive has no known filesystem and must be formatted'
				G_WHIP_MENU_ARRAY+=('Format' ': Create a filesystem for this drive/partition')

			fi

		#Filesystem
		else

			if [[ ${aDRIVE_FSTYPE[$INDEX_DRIVE_BEING_EDITED]} ]]; then

				whiptail_desc+="\nFilesystem:   ${aDRIVE_FSTYPE[$INDEX_DRIVE_BEING_EDITED]}"

			fi

			if [[ ${aDRIVE_UUID[$INDEX_DRIVE_BEING_EDITED]} ]]; then

				whiptail_desc+="\nUUID:         ${aDRIVE_UUID[$INDEX_DRIVE_BEING_EDITED]}"

			fi

			if (( ${aDRIVE_ISMOUNTED[$INDEX_DRIVE_BEING_EDITED]} )); then

				whiptail_desc+="\nAllocation:   Capacity: ${aDRIVE_SIZE_TOTAL[$INDEX_DRIVE_BEING_EDITED]}b | Used: ${aDRIVE_SIZE_USED[$INDEX_DRIVE_BEING_EDITED]}b (${aDRIVE_SIZE_PERCENTUSED[$INDEX_DRIVE_BEING_EDITED]})"
				whiptail_desc+='\nStatus:       Drive is online and ready for use'

				#Unmount
				# - Disable mount control for /boot /rootfs
				if [[ ${aDRIVE_MOUNT_TARGET[$INDEX_DRIVE_BEING_EDITED]} != '/' && ${aDRIVE_MOUNT_TARGET[$INDEX_DRIVE_BEING_EDITED]} != '/boot' ]]; then

					G_WHIP_MENU_ARRAY+=('' '●─ Mount Control ')
					if (( ${aDRIVE_ISNETWORKED[$INDEX_DRIVE_BEING_EDITED]} )); then

						G_WHIP_MENU_ARRAY+=('Remove' ': Unmount networked drive and remove it from database')

					else

						G_WHIP_MENU_ARRAY+=('Unmount' ': Allows you to physically remove the drive')

					fi

				fi

				if (( ! ${aDRIVE_ISROM[$INDEX_DRIVE_BEING_EDITED]} )); then

					if (( ! ${aDRIVE_ISREADONLY_CURRENTLY[$INDEX_DRIVE_BEING_EDITED]} )); then

						G_WHIP_MENU_ARRAY+=('' '●─ Benchmark Options ')
						G_WHIP_MENU_ARRAY+=('Benchmark' ': Test read and write speeds')

						#Userdata location/swapfile
						if (( ! ${aDRIVE_ISNETWORKED[$INDEX_DRIVE_BEING_EDITED]} )); then

							G_WHIP_MENU_ARRAY+=('' '●─ Userdata & Swap options ')

							if { [[ ${aDRIVE_MOUNT_TARGET[$INDEX_DRIVE_BEING_EDITED]} != '/' && $FP_USERDATA_CURRENT == ${aDRIVE_MOUNT_TARGET[$INDEX_DRIVE_BEING_EDITED]}* ]]; } || #off rootfs
								{ [[ ${aDRIVE_MOUNT_TARGET[$INDEX_DRIVE_BEING_EDITED]} == '/' && $FP_USERDATA_CURRENT == $G_FP_DIETPI_USERDATA ]]; }; then #on rootfs

								G_WHIP_MENU_ARRAY+=('User data' ": [X] | DietPi user data is currently located on this drive")
								partition_contains_userdata=1

							else

								G_WHIP_MENU_ARRAY+=('User data' ': [ ] | Select to transfer DietPi user data to this drive')

							fi

							# - Swapfile
							#	NB: / rootfs will always be detected in this check, however, no rootFS options for umount and format...
							local swapfile_size=$(grep -m1 '^[[:blank:]]*AUTO_SETUP_SWAPFILE_SIZE=' /DietPi/dietpi.txt | sed 's/^[^=]*=//')
							if (( $swapfile_size > 0 )) &&
								( [[ $FP_SWAPFILE_CURRENT == ${aDRIVE_MOUNT_TARGET[$INDEX_DRIVE_BEING_EDITED]}* && ${aDRIVE_MOUNT_TARGET[$INDEX_DRIVE_BEING_EDITED]} != '/' ]] || [[ $FP_SWAPFILE_CURRENT == '/var/swap' && ${aDRIVE_MOUNT_TARGET[$INDEX_DRIVE_BEING_EDITED]} == '/' ]] ); then

								partition_contains_swapfile=1
								G_WHIP_MENU_ARRAY+=('Swapfile' ": [X] | ${swapfile_size}MB used on this drive, select to change size")

							else

								G_WHIP_MENU_ARRAY+=('Swapfile' ': [ ] | Select to transfer swapfile to this drive')

							fi

						fi

					fi

					if (( ! ${aDRIVE_ISNETWORKED[$INDEX_DRIVE_BEING_EDITED]} )); then

						G_WHIP_MENU_ARRAY+=('' '●─ Advanced options ')

						# - Read only?
						local read_only_state='[X]'
						local read_only_state_text='Enabled'
						if (( ! ${aDRIVE_ISREADONLY_CURRENTLY[$INDEX_DRIVE_BEING_EDITED]} )); then

							read_only_state='[ ]'
							read_only_state_text='Disabled'

						fi
						G_WHIP_MENU_ARRAY+=('Read Only' ": $read_only_state | Select to toggle RW/RO modes")
						whiptail_desc+="\nRead only:    $read_only_state_text"

						# Show reserved blocks percentage for ext4 drives behind capacity:
						if [[ ${aDRIVE_FSTYPE[$INDEX_DRIVE_BEING_EDITED]} == 'ext4' ]]; then

							local reserved_blocks_percent_current=0
							local fp_temp='.dietpi-drive_manager_dumpe2fs'
							dumpe2fs -h "${aDRIVE_MOUNT_SOURCE[$INDEX_DRIVE_BEING_EDITED]}" > $fp_temp
							local block_count="$(grep -m1 '^Block count:' $fp_temp | awk '{print $3}')"
							local reserved_block_count="$(grep -m1 '^Reserved block count:' $fp_temp | awk '{print $4}')"
							rm $fp_temp
							reserved_blocks_percent_current="$(bc -l <<< "scale=3;(100*$reserved_block_count)/$block_count")"
							# Correct rounding to final scale:
							reserved_blocks_percent_current="$(bc -l <<< "scale=2;(($reserved_blocks_percent_current*100)+0.5)/100" | sed 's/^\./0\./' | sed '/.0$/s/0$//' | sed 's/\.0$//')"
							G_WHIP_MENU_ARRAY+=('Reserved blocks' ": [$reserved_blocks_percent_current%] | Adjust percentage of reserved blocks on this drive")

						fi

					fi

				fi

			else

				whiptail_desc+='\nStatus:       Drive is not mounted and can be unplugged'
				G_WHIP_MENU_ARRAY+=('' '●─ Mount Control ')
				G_WHIP_MENU_ARRAY+=('Mount' ": Mount the drive to ${aDRIVE_MOUNT_TARGET[$INDEX_DRIVE_BEING_EDITED]}")
				G_WHIP_MENU_ARRAY+=('' '●─ Advanced Options ')

			fi

			if ! (( ${aDRIVE_ISROM[$INDEX_DRIVE_BEING_EDITED]} || ${aDRIVE_ISNETWORKED[$INDEX_DRIVE_BEING_EDITED]} )); then

				# - fsck
				G_WHIP_MENU_ARRAY+=('Check & Repair' ': Check and optionally repair filesystem')

				# - Resize
				if (( ! ${aDRIVE_ISREADONLY_CURRENTLY[$INDEX_DRIVE_BEING_EDITED]} )) &&
					[[ ${aDRIVE_FSTYPE[$INDEX_DRIVE_BEING_EDITED]} == 'ext4' ]]; then

					G_WHIP_MENU_ARRAY+=('Resize' ': Maximize the available filesystem size')

				fi

				#- Transfer RootFS
				if [[ ${aDRIVE_MOUNT_SOURCE[$INDEX_DRIVE_BEING_EDITED]} != $FP_ROOTFS_SOURCE ]] &&
					(( $G_HW_MODEL <= 12 )); then

					G_WHIP_MENU_ARRAY+=('Transfer RootFS' ': Transfer RootFS to this drive')

				fi

				# - Disable format for /boot /rootfs
				if [[ ${aDRIVE_MOUNT_TARGET[$INDEX_DRIVE_BEING_EDITED]} != '/' && ${aDRIVE_MOUNT_TARGET[$INDEX_DRIVE_BEING_EDITED]} != '/boot' ]]; then

					G_WHIP_MENU_ARRAY+=('Format' ': Select to see formatting options')

				fi

			fi

		fi

		G_WHIP_BUTTON_CANCEL_TEXT='Back'
		G_WHIP_DEFAULT_ITEM="$MENU_LASTITEM"
		if G_WHIP_MENU "$whiptail_desc"; then

			MENU_LASTITEM="$G_WHIP_RETURNED_VALUE"

			if [[ $G_WHIP_RETURNED_VALUE == 'Mount' ]]; then

				Mount_Drive ${aDRIVE_MOUNT_SOURCE[$INDEX_DRIVE_BEING_EDITED]} ${aDRIVE_MOUNT_TARGET[$INDEX_DRIVE_BEING_EDITED]}

			elif [[ $G_WHIP_RETURNED_VALUE == 'Unmount' || $G_WHIP_RETURNED_VALUE == 'Remove' ]]; then

				# - Disallow if userdata is located on this drive!
				if (( $partition_contains_userdata )); then

					Notification 0

				elif (( $partition_contains_swapfile )); then

					Notification 1

				else

					if [[ $G_WHIP_RETURNED_VALUE == 'Remove' ]]; then

						if G_WHIP_YESNO "Do you wish to unmount and remove the following networked drive from this system?
 - ${aDRIVE_MOUNT_SOURCE[$INDEX_DRIVE_BEING_EDITED]} > ${aDRIVE_MOUNT_TARGET[$INDEX_DRIVE_BEING_EDITED]}
\nNB: You can add additional network shares at a later date through the 'dietpi-drive_manager' main menu."; then

							Unmount_Drive ${aDRIVE_MOUNT_TARGET[$INDEX_DRIVE_BEING_EDITED]}
							TARGETMENUID=0

						fi

					else

						Unmount_Drive ${aDRIVE_MOUNT_TARGET[$INDEX_DRIVE_BEING_EDITED]}

					fi

				fi

			elif [[ $G_WHIP_RETURNED_VALUE == 'Swapfile' ]]; then

				local min=0
				local current_freespace=$(G_CHECK_FREESPACE ${aDRIVE_MOUNT_TARGET[$INDEX_DRIVE_BEING_EDITED]})
				local max=$(( $current_freespace - 2000 ))
				if (( $max < $min )); then

					G_WHIP_MSG "Error: Insufficent free space on ${aDRIVE_MOUNT_TARGET[$INDEX_DRIVE_BEING_EDITED]}, a minimum of 2GB is required ($current_freespace MB available)."

				else

					G_WHIP_DEFAULT_ITEM=$swapfile_size
					if G_WHIP_INPUTBOX "Please input a new value for swapfile size (MB):
\nSwapfile has a swapiness setting of 1, and, is used only to prevent out of memory errors.
\n - Recommended value = 1 (auto)\n - 0 = Disable swapfile\n - 1 = Auto size swapfile (2GB - RAM = size)\n - 2 - $max = Manual size"; then

						if G_CHECK_VALIDINT $G_WHIP_RETURNED_VALUE $min $max; then

							local fp_target_swapfile="${aDRIVE_MOUNT_TARGET[$INDEX_DRIVE_BEING_EDITED]}/.swapfile"
							[[ ${aDRIVE_MOUNT_TARGET[$INDEX_DRIVE_BEING_EDITED]} == '/' ]] && fp_target_swapfile='/var/swap'

							/DietPi/dietpi/func/dietpi-set_dphys-swapfile $G_WHIP_RETURNED_VALUE "$fp_target_swapfile"

						fi

					fi

				fi

			elif [[ $G_WHIP_RETURNED_VALUE == 'Reserved blocks' ]]; then

				while :
				do

					G_WHIP_DEFAULT_ITEM="$reserved_blocks_percent_current"
					G_WHIP_INPUTBOX 'Ext4 formatted drives allow the reservation of drive space for the root user to assure system functionality, if filled by other users or processes, and to avoid fragmentation of large files.\n\nHowever, on modern drives, the default of 5% reserved blocks is often by orders of magnitude larger than necessary. You may want to reduce the percentage to an absolute reserved space of about 500 MiB, which should be enough, to enable root user starting and maintaining the system. Additionally, on non rootfs drives reserved blocks are not necessary at all.\n\nPlease enter the desired percentage of reserved blocks, e.g. "0.05" for 0.05% or "10" for 10%.\nNote: Only values between "0" and "50" are allowed.'
					if (( $? )); then

						break

					else

						if grep -qE '^[0-9]*\.?[0-9]*$' <<< "$G_WHIP_RETURNED_VALUE" &&
							[[ $G_WHIP_RETURNED_VALUE != '.' ]] &&
							(( $(bc -l <<< "$G_WHIP_RETURNED_VALUE <= 50") )); then

							G_RUN_CMD tune2fs -m "$G_WHIP_RETURNED_VALUE" "${aDRIVE_MOUNT_SOURCE[$INDEX_DRIVE_BEING_EDITED]}"
							break

						else

							G_WHIP_MSG 'Error: Allowed are only integers or floats between "0" and "50", e.g. "10" or "0.5".\n\nPlease try again...'

						fi

					fi

				done

			elif [[ $G_WHIP_RETURNED_VALUE == 'User data' ]]; then

				local fp_target_userdata_dir="${aDRIVE_MOUNT_TARGET[$INDEX_DRIVE_BEING_EDITED]}"
				#	Assign location if under RootFS
				[[ ${aDRIVE_MOUNT_TARGET[$INDEX_DRIVE_BEING_EDITED]} == '/' ]] && fp_target_userdata_dir='/mnt'

				fp_target_userdata_dir+='/dietpi_userdata'

				if [[ $fp_target_userdata_dir != $FP_USERDATA_CURRENT ]]; then

					G_WHIP_YESNO "Your user data will be moved:\n - From: $FP_USERDATA_CURRENT\n - To: $fp_target_userdata_dir\n\nDo you wish to continue?"
					if (( ! $? )); then

						export G_DIETPI_SERVICES_DISABLE=1
						/DietPi/dietpi/func/dietpi-set_userdata "$FP_USERDATA_CURRENT" "$fp_target_userdata_dir"
						sleep 1
						export G_DIETPI_SERVICES_DISABLE=0

					fi

				fi

			elif [[ $G_WHIP_RETURNED_VALUE == 'Format' ]]; then

				# - Disallow if userdata is located on this drive!
				if (( $partition_contains_userdata )); then

					Notification 0

				elif (( $partition_contains_swapfile )); then

					Notification 1

				#	user must unmount partition on this drive, before we can format, this ensures a valid unmount check
				elif (( ${aDRIVE_ISMOUNTED[$INDEX_DRIVE_BEING_EDITED]} )); then

					G_WHIP_MSG "The partition (${aDRIVE_MOUNT_SOURCE[$INDEX_DRIVE_BEING_EDITED]}) must be unmounted, before formatting is allowed.\n\nPlease use the option 'Unmount' on the next screen, then retry the 'Format' option."

				else

					TARGETMENUID=2

				fi

			#Resize
			elif [[ $G_WHIP_RETURNED_VALUE == 'Resize' ]]; then

				Resize_FS

			#Transfer RootFS
			elif [[ $G_WHIP_RETURNED_VALUE == 'Transfer RootFS' ]]; then

				#	user must unmount partition before format
				if (( ${aDRIVE_ISMOUNTED[$INDEX_DRIVE_BEING_EDITED]} )); then

					G_WHIP_MSG 'Partition must be unmounted, before format and RootFS transfer can begin.\n\nPlease unmount the partition, then try again.'

				else

					if G_WHIP_YESNO "This process will move RootFS data to another location. This may increase filesystem performance when using a USB drive over SD card, however, there are some limitations:
\n - The SD/EMMC card is still required for the boot process
\nNB: As this feature is still in testing, we recommend you use this feature on a fresh installation only.\n\nDo you wish to continue?"; then

						G_WHIP_MSG 'On the next screen, you will be asked to format the target partition.
\nPlease see the following recommendations for RootFS target filesystem type:
\n - Odroid\nRootFS transfer supports ONLY EXT4 format\n\n - RPi\nRootFS transfer supports EXT4, BTRFS and F2FS'

						#NB: We dont enter main loop in this func
						TARGETMENUID=2
						while (( $TARGETMENUID == 2 ))
						do

							Menu_Format

						done

						(( $FORMAT_COMPLETED )) && RootFS_Move

					fi

				fi

			elif [[ $G_WHIP_RETURNED_VALUE == 'Read Only' ]]; then

				# - Disallow if userdata is located on this drive!
				if (( $partition_contains_swapfile )); then

					Notification 1

				else

					Toggle_WriteMode

				fi

			elif [[ $G_WHIP_RETURNED_VALUE == 'Benchmark' ]]; then

				FP_BENCHFILE="${aDRIVE_MOUNT_TARGET[$INDEX_DRIVE_BEING_EDITED]}" /DietPi/dietpi/func/dietpi-benchmark 1

			elif [[ $G_WHIP_RETURNED_VALUE == 'Check & Repair' ]]; then

				if [[ ${aDRIVE_MOUNT_TARGET[$INDEX_DRIVE_BEING_EDITED]} == '/' ]]; then

					if G_WHIP_YESNO 'The root file system can only be checked on reboot.
\nDo you want to force a file system check of root partition on next reboot?
\nNB: Logs can be found after reboot either via "journalctl -t systemd-fsck" or "cat /run/initramfs/fsck.log"'; then

						> /forcefsck
						G_WHIP_YESNO 'Do you want to reboot now?' && reboot

					fi
					return

				fi

				if (( ${aDRIVE_ISMOUNTED[$INDEX_DRIVE_BEING_EDITED]} )); then

					G_WHIP_YESNO 'For safe check and repair, the drive needs to be unmounted.
\nDo you want to continue with the drive being unmounted automatically?' || { TARGETMENUID=1 && return; }

					# - disable swap
					(( $partition_contains_swapfile )) && G_RUN_CMD swapoff -a

					# - Unmount drive
					G_RUN_CMD umount ${aDRIVE_MOUNT_SOURCE[$INDEX_DRIVE_BEING_EDITED]}

				fi

				if [[ ${aDRIVE_FSTYPE[$INDEX_DRIVE_BEING_EDITED]} =~ 'ext' ]]; then

					local fsck_dry='e2fsck -n -f'
					local fsck_fix='e2fsck -y -f'

				elif [[ ${aDRIVE_FSTYPE[$INDEX_DRIVE_BEING_EDITED]} == 'exfat' ]]; then

					G_AG_CHECK_INSTALL_PREREQ exfat-utils exfat-fuse
					local fsck_fix='exfatfsck'

				elif [[ ${aDRIVE_FSTYPE[$INDEX_DRIVE_BEING_EDITED]} =~ 'fat' ]]; then

					G_AG_CHECK_INSTALL_PREREQ dosfstools
					local fsck_dry='fsck.fat -n'
					local fsck_fix='fsck.fat -y'

				elif [[ ${aDRIVE_FSTYPE[$INDEX_DRIVE_BEING_EDITED]} == 'ntfs' ]]; then

					G_AG_CHECK_INSTALL_PREREQ ntfs-3g
					local fsck_dry='ntfsfix -n'
					local fsck_fix='ntfsfix'

				elif [[ ${aDRIVE_FSTYPE[$INDEX_DRIVE_BEING_EDITED]} =~ 'hfs' ]]; then

					G_AG_CHECK_INSTALL_PREREQ hfsplus hfsprogs hfsutils
					local fsck_dry='fsck.hfsplus -n -f'
					local fsck_fix='fsck.hfsplus -y -f'

				elif [[ ${aDRIVE_FSTYPE[$INDEX_DRIVE_BEING_EDITED]} == 'f2fs' ]]; then

					G_AG_CHECK_INSTALL_PREREQ f2fs-tools
					local fsck_dry='fsck.f2fs'
					local fsck_fix='fsck.f2fs -f'

				elif [[ ${aDRIVE_FSTYPE[$INDEX_DRIVE_BEING_EDITED]} == 'btrfs' ]]; then

					G_AG_CHECK_INSTALL_PREREQ btrfs-tools
					local fsck_dry='btrfs check --readonly'
					local fsck_fix='btrfs check --repair'

				else

					G_WHIP_MSG "File system checks are currently not supported for '${aDRIVE_FSTYPE[$INDEX_DRIVE_BEING_EDITED]}'. Aborting..."
					TARGETMENUID=1
					return

				fi

				# Do dry-run first for file systems supporting it:
				if [[ $fsck_dry ]]; then

					G_WHIP_MSG "The following drive will now be checked for errors:\n${aDRIVE_MOUNT_SOURCE[$INDEX_DRIVE_BEING_EDITED]}\n\nNo repair will be completed during this process. An option to repair the drive, will be provided after the check."
					$fsck_dry ${aDRIVE_MOUNT_SOURCE[$INDEX_DRIVE_BEING_EDITED]} &> .dietpi-drive_manager_check.log
					log=1 G_WHIP_VIEWFILE .dietpi-drive_manager_check.log
					rm .dietpi-drive_manager_check.log &> /dev/null

				fi

				G_WHIP_YESNO "Would you like to run an automated repair on the following drive now?\n       ${aDRIVE_MOUNT_SOURCE[$INDEX_DRIVE_BEING_EDITED]}\n
NB:
- Automated repair steps potentially lead to data loss, which would have been able to recover by professional drive recovery services.
- If the data is extremely important and you don't have any backup, you might want to hand the drive to a recovery service as is.
- These services are usually very expensive, but might be able to recover more data than (after) this automated repair steps!"
				if (( ! $? )); then

					$fsck_fix ${aDRIVE_MOUNT_SOURCE[$INDEX_DRIVE_BEING_EDITED]} &> .dietpi-drive_manager_repair.log
					log=1 G_WHIP_VIEWFILE .dietpi-drive_manager_repair.log
					rm .dietpi-drive_manager_repair.log &> /dev/null

				fi

				# - Remount all drives
				G_RUN_CMD mount -a

				# - Re-enable swap
				(( $partition_contains_swapfile )) && G_RUN_CMD swapon -a

			fi

		#Exit
		else

			TARGETMENUID=0

		fi

		unset whiptail_desc

		#Always init/refresh drives for next loop
		Init_Drives_and_Refresh

	}

	Menu_Format(){

		TARGETMENUID=2

		FORMAT_COMPLETED=0

		local partition_table_text='GPT'
		(( $FORMAT_GPT )) || partition_table_text='MBR'

		local format_mode_text='Drive'
		(( $FORMAT_MODE == 1 )) && format_mode_text='Partition'

		local format_type_text='EXT4'
		if (( $FORMAT_FILESYSTEM_TYPE == 1 )); then

			format_type_text='NTFS'

		elif (( $FORMAT_FILESYSTEM_TYPE == 2 )); then

			format_type_text='FAT32'

		elif (( $FORMAT_FILESYSTEM_TYPE == 3 )); then

			format_type_text='HFS+'

		elif (( $FORMAT_FILESYSTEM_TYPE == 4 )); then

			format_type_text='BTRFS'

		elif (( $FORMAT_FILESYSTEM_TYPE == 5 )); then

			format_type_text='F2FS'

		elif (( $FORMAT_FILESYSTEM_TYPE == 6 )); then

			format_type_text='EXFAT'

		fi

		G_WHIP_MENU_ARRAY=()

		# - No partition table, force drive wipe
		if (( ! ${aDRIVE_ISPARTITIONTABLE[$INDEX_DRIVE_BEING_EDITED]} )); then

			FORMAT_MODE=0

		# - Has partition table, offer modes
		else

			G_WHIP_MENU_ARRAY+=('Format Mode' ": $format_mode_text")

		fi

		(( $FORMAT_MODE == 0 )) && G_WHIP_MENU_ARRAY+=('Partition Type' ": $partition_table_text")

		G_WHIP_MENU_ARRAY+=('Filesystem Type' ": $format_type_text")
		G_WHIP_MENU_ARRAY+=('Format' ': Start the format process with selected options')

		G_WHIP_DEFAULT_ITEM="$MENU_LASTITEM"
		G_WHIP_BUTTON_CANCEL_TEXT='Back'
		if G_WHIP_MENU 'Please select formatting options:'; then

			MENU_LASTITEM="$G_WHIP_RETURNED_VALUE"

			if [[ $G_WHIP_RETURNED_VALUE == 'Partition Type' ]]; then

				FORMAT_GPT=1

				G_WHIP_BUTTON_OK_TEXT='MBR'
				G_WHIP_BUTTON_CANCEL_TEXT='GPT'
				G_WHIP_YESNO 'Would you like to use GPT or MBR parition table?\n - GPT is required for 2TB+ drives\n - MBR does NOT support 2TB+ drives\n\nIf unsure, select GPT (default)'
				if (( ! $? )); then

					FORMAT_GPT=0
					partition_table_text='MBR'

				fi

			elif [[ $G_WHIP_RETURNED_VALUE == 'Format Mode' ]]; then

				G_WHIP_MENU_ARRAY=(

					'Partition' ": ${aDRIVE_MOUNT_SOURCE[$INDEX_DRIVE_BEING_EDITED]} | UUID=${aDRIVE_UUID[$INDEX_DRIVE_BEING_EDITED]}"
					'Drive' ": /dev/${aDRIVE_SOURCE_DEVICE[$INDEX_DRIVE_BEING_EDITED]}"

				)

				G_WHIP_MENU 'Please select a formatting mode:\n\n - Formatting the drive will DELETE all data on the DRIVE.\n - Formatting the partition, will DELETE all data on the current PARTITION only.\n\nNB: If you are planning to dedicate the drive to this system, it is recommended to format the whole drive where possible, this will ensure full drive capacity is available for use.'
				if (( ! $? )); then

					FORMAT_MODE=0
					[[ ${G_WHIP_RETURNED_VALUE,,} == 'partition' ]] && FORMAT_MODE=1

				fi

			elif [[ $G_WHIP_RETURNED_VALUE == 'Filesystem Type' ]]; then

				G_WHIP_MENU_ARRAY=(

					'0' ': EXT4   | Default (Recommended)'
					'1' ': NTFS   | Windows (High CPU usage)'
					'2' ': FAT32  | All OS (4GB filesize limit)'
					'3' ': HFS+   | Mac OS X (Intel Mac default file system)'
					'4' ': BTRFS  | Linux (Modern filesystem)'
					'5' ': F2FS   | Linux (Flash filesystem)'
					'6' ': exFAT  | Windows (Flash filesystem)'

				)

				G_WHIP_DEFAULT_ITEM="$FORMAT_FILESYSTEM_TYPE"
				G_WHIP_MENU 'Please select a filesystem type for this format:\n\nEXT4:\nHighly recommended if you plan to use this drive solely on this system (dedicated drive).\n\nNTFS:\nRecommended if you plan to use this drive on a Windows system. High CPU usage during transfers.\n\nFull list of different filesystem types:\nhttps://dietpi.com/phpbb/viewtopic.php?f=8&t=673&p=2898#p2898'
				if (( ! $? )); then

					# Install FS pre-reqs
					# - NTFS
					if (( $G_WHIP_RETURNED_VALUE == 1 )); then

						G_AG_CHECK_INSTALL_PREREQ ntfs-3g

					# - FAT32
					elif (( $G_WHIP_RETURNED_VALUE == 2 )); then

						G_AG_CHECK_INSTALL_PREREQ dosfstools

					# - HFS+
					elif (( $G_WHIP_RETURNED_VALUE == 3 )); then

						G_AG_CHECK_INSTALL_PREREQ hfsplus hfsprogs hfsutils

					# - Btrfs
					elif (( $G_WHIP_RETURNED_VALUE == 4 )); then

						G_AG_CHECK_INSTALL_PREREQ btrfs-tools

 					# - F2FS
					elif (( $G_WHIP_RETURNED_VALUE == 5 )); then

						G_AG_CHECK_INSTALL_PREREQ f2fs-tools

					# - exFAT
					elif (( $G_WHIP_RETURNED_VALUE == 6 )); then

						G_AG_CHECK_INSTALL_PREREQ exfat-utils exfat-fuse

					fi

					FORMAT_FILESYSTEM_TYPE="$G_WHIP_RETURNED_VALUE"

				fi

			elif [[ $G_WHIP_RETURNED_VALUE == 'Format' ]]; then

				Run_Format

				TARGETMENUID=1

			fi

		else

			TARGETMENUID=1

		fi

	}

	Mount_Samba(){

		rm /mnt/samba/readme.txt &> /dev/null

		local samba_clientname=''
		local samba_clientshare=''
		local samba_clientuser=''
		local samba_clientpassword=''
		local samba_fp_mount_target='samba'

		while :
		do

			G_WHIP_DEFAULT_ITEM="$samba_clientname"
			G_WHIP_INPUTBOX 'Please enter the fileservers IP address\n - eg: 192.168.0.2' || break
			samba_clientname="$G_WHIP_RETURNED_VALUE"

			G_WHIP_DEFAULT_ITEM="$samba_clientshare"
			G_WHIP_INPUTBOX 'Please enter the fileservers shared folder name\n - eg: MySharedFolder' || break
			#	NB: Convert spaces into '\040': https://github.com/Fourdee/DietPi/issues/1201#issuecomment-339720271
			samba_clientshare="${G_WHIP_RETURNED_VALUE//[[:space:]]/\\\\040}"

			G_WHIP_DEFAULT_ITEM="$samba_clientuser"
			G_WHIP_INPUTBOX 'Please enter the fileservers username\n - eg: JoeBloggs' || break
			samba_clientuser="$G_WHIP_RETURNED_VALUE"

			G_WHIP_DEFAULT_ITEM="$samba_clientpassword"
			G_WHIP_PASSWORD 'Please enter the fileservers password\n - eg: LetMeIn' || break
			samba_clientpassword="$result"
			unset result

			G_WHIP_DEFAULT_ITEM="$samba_fp_mount_target"
			G_WHIP_INPUTBOX 'Please enter a unique folder name for the mount location (eg: samba). This will be placed in /mnt/' || break
			samba_fp_mount_target="/mnt/${G_WHIP_RETURNED_VALUE//[[:space:]]/_}"

			# - Unmount if connected
			umount /mnt/$samba_fp_mount_target &> /dev/null

			G_AG_CHECK_INSTALL_PREREQ smbclient cifs-utils

			#Mount now
			mkdir -p $samba_fp_mount_target

			# - Mount from highest SMB version to lowest, until we find a successful one
			local acifs_versions=(

				'3.1'
				'3.0'
				'2.1'
				'2.0'
				'1.0'

			)

			for i in ${!acifs_versions[@]}
			do
				G_DIETPI-NOTIFY 2 "Attempting to mount with CIFS version: ${acifs_versions[$i]}"
				mount -t cifs -o username="$samba_clientuser",password="$samba_clientpassword",uid=dietpi,gid=dietpi,file_mode=0770,dir_mode=0770,vers=${acifs_versions[$i]} //"$samba_clientname"/"$samba_clientshare" "$samba_fp_mount_target" &> /dev/null
				if (( $? == 0 )); then

					# - Apply to fstab
					sed -i "\#[[:space:]]$samba_fp_mount_target[[:space:]]#d" /etc/fstab
					echo "//$samba_clientname/$samba_clientshare $samba_fp_mount_target cifs username=$samba_clientuser,password=$samba_clientpassword,iocharset=utf8,uid=dietpi,gid=dietpi,file_mode=0770,dir_mode=0770,vers=${acifs_versions[$i]},_netdev,nofail 0 0" >> /etc/fstab

					DRIVE_TARGET_BEING_EDITED="$samba_fp_mount_target"
					TARGETMENUID=1

					G_WHIP_MSG "Mount completed. The new mount can be accessed via:\n - $samba_fp_mount_target\n - CIFS vers=${acifs_versions[$i]}"
					break

				fi

				# - Last item already failed, rerun for user info
				if (( $i == ${#acifs_versions[@]} - 1 )); then

					# - Run mount again, allow user to see error
					G_ERROR_HANDLER_INFO_ONLY=1 G_RUN_CMD mount -t cifs -o username="$samba_clientuser",password="$samba_clientpassword",uid=dietpi,gid=dietpi,file_mode=0770,dir_mode=0770,vers=${acifs_versions[$i]} //"$samba_clientname"/"$samba_clientshare" "$samba_fp_mount_target"
					Rm_Empty_Dir "$samba_fp_mount_target"
					break

				fi

			done

			unset acifs_versions

			break

		done

	}

	Mount_NFS(){

		local fp_tmp='.mount_out'
		local nfs_server_ip='192.168.'
		local nfs_fp_mount_target='/mnt/nfs_client'
		# Server-side path to share, needed for NFSv3 only
		local nfs_fp_server_share='/'

		rm /mnt/nfs_client/readme.txt &> /dev/null
		Rm_Empty_Dir /mnt/nfs_client

		while :
		do

			G_WHIP_DEFAULT_ITEM="$nfs_server_ip"
			G_WHIP_INPUTBOX 'Please enter the NFS servers IP address (eg: 192.168.0.2).' || break
			nfs_server_ip="$G_WHIP_RETURNED_VALUE"

			# - Show current chosen mount target without leading "/mnt/"
			G_WHIP_DEFAULT_ITEM="${nfs_fp_mount_target#/mnt/}"
			G_WHIP_INPUTBOX 'Please enter a unique folder name for the mount location (eg: nfs_client). This will be placed in /mnt/
\nNB: Please avoid white spaces or special characters for compatibility reasons.' || break
			# - Remove leading "/mnt/", in case entered by user
			nfs_fp_mount_target="${G_WHIP_RETURNED_VALUE#/mnt/}"
			# - Remove leading slash and (re-)add "/mnt/" for full mount target path
			nfs_fp_mount_target="/mnt/${nfs_fp_mount_target#/}"
			# - Replace all spaces (+ tabs etc) with "_"
			nfs_fp_mount_target="${nfs_fp_mount_target//[[:space:]]/_}"

			# - Unmount if connected
			umount $nfs_fp_mount_target &> /dev/null

			G_AG_CHECK_INSTALL_PREREQ nfs-common netbase

			#Mount now
			mkdir -p $nfs_fp_mount_target

			if mount -vt nfs -o port=2049 "$nfs_server_ip":/ $nfs_fp_mount_target &> $fp_tmp; then

				rm $fp_tmp

				#Apply to fstab
				sed -i "\#[[:space:]]$nfs_fp_mount_target[[:space:]]#d" /etc/fstab
				echo "$nfs_server_ip:/ $nfs_fp_mount_target nfs auto,_netdev,nofail 0 0" >> /etc/fstab

				DRIVE_TARGET_BEING_EDITED="$nfs_fp_mount_target"
				TARGETMENUID=1

				G_WHIP_MSG "Mount completed. The new mount can be accessed via:\n - $nfs_fp_mount_target"
				return 0

			# Detect NFSv3 server, which requires server side path to share directory:
			elif grep -q '[[:blank:]]vers 3[[:blank:]]' $fp_tmp &&
				grep -q 'access denied by server while mounting' $fp_tmp; then

				G_WHIP_DEFAULT_ITEM="$nfs_fp_server_share"
				G_WHIP_INPUTBOX 'Your NFS server appears to support NFSv3 only. Mounting NFSv3 shares requires the shares path server side to be entered.
\nPlease enter the absolute path to the share on the NFS server (eg: /mnt/nfs_share).' || break
				nfs_fp_server_share="$G_WHIP_RETURNED_VALUE"

				if mount -vt nfs -o port=2049 "$nfs_server_ip":"$nfs_fp_server_share" $nfs_fp_mount_target &> $fp_tmp; then

					rm $fp_tmp

					#Apply to fstab
					sed -i "\#[[:space:]]$nfs_fp_mount_target[[:space:]]#d" /etc/fstab
					echo "$nfs_server_ip:$nfs_fp_server_share $nfs_fp_mount_target nfs auto,_netdev,nofail 0 0" >> /etc/fstab

					DRIVE_TARGET_BEING_EDITED="$nfs_fp_mount_target"
					TARGETMENUID=1

					G_WHIP_MSG "Mount completed. The new mount can be accessed via:\n - $nfs_fp_mount_target"
					return 0

				fi

			fi

			# Offer retry if drive could not be mounted
			if [[ -f $fp_tmp ]]; then

				G_WHIP_YESNO "Mounting NFS drive has failed. Either the NFS server is not reachable or your entered invalid inputs.
Do you want to retry?

Error log:
$(<$fp_tmp)" || break

			fi

		done

		rm $fp_tmp &> /dev/null
		Rm_Empty_Dir $nfs_fp_mount_target

	}

	Menu_Add_Network_Drive(){

		TARGETMENUID=3

		G_WHIP_MENU_ARRAY=(

			'Samba' ': Setup a connection for a Samba/CIFS/Windows compatible file share'
			'NFS' ': Setup a connection for a NFS compatible file share'

		)

		if G_WHIP_MENU 'Please select a mount location to use:'; then

			if [[ $G_WHIP_RETURNED_VALUE == 'Samba' ]]; then

				Mount_Samba

			elif [[ $G_WHIP_RETURNED_VALUE == 'NFS' ]]; then

				Mount_NFS

			fi

			Init_Drives_and_Refresh

		else

			TARGETMENUID=0

		fi

	}

	Menu_Select_Mount_Location(){

		#Generate menu
		G_WHIP_MENU_ARRAY=()

		df -Ph | tail -n +2 | sed '/tmpfs/d' | sed '/^udev/d' > dietpi-drive_manager_selmnt

		while read line
		do

			G_WHIP_MENU_ARRAY+=("$(awk '{print $6}' <<< $line)" ": $(awk '{print $1}' <<< $line) | size: $(awk '{print $2}' <<< $line) | available: $(awk '{print $4}' <<< $line)")

		done < dietpi-drive_manager_selmnt
		rm dietpi-drive_manager_selmnt

		G_WHIP_DEFAULT_ITEM="$MENU_LASTITEM"
		if G_WHIP_MENU 'Please select a mount location to use:'; then

			local drive_manager_selection="$G_WHIP_RETURNED_VALUE"

			G_DIETPI-NOTIFY 0 "Drive mount selected: $drive_manager_selection"
			echo "$drive_manager_selection" > "$FP_DRIVE_MANAGER_SELECTION"

		fi

	}

	Menu_Exit(){

		G_WHIP_SIZE_X_MAX=50
		if G_WHIP_YESNO "Exit $G_PROGRAM_NAME?"; then

			#exit
			TARGETMENUID=-1

		else

			#Return to Main Menu
			TARGETMENUID=0

		fi

	}

	#/////////////////////////////////////////////////////////////////////////////////////
	# Main Loop
	#/////////////////////////////////////////////////////////////////////////////////////
	(( $INPUT >= 1 )) && SERVICE_CONTROL=0
	#-----------------------------------------------------------------------------------
	# Stop Services
	(( $SERVICE_CONTROL )) && /DietPi/dietpi/dietpi-services stop
	#-----------------------------------------------------------------------------------
	#Generate /etc/fstab based on current drive mounts
	if (( $INPUT == 4 )); then

		Init_Drives_and_Refresh

	#Menu system for user to select an active mount and return value
	elif (( $INPUT == 1 )); then

		Init_Drives_and_Refresh
		Menu_Select_Mount_Location

	#Drive Manager
	else

		Init_Drives_and_Refresh

		while (( $TARGETMENUID > -1 )); do

			printf '\ec'

			if (( $TARGETMENUID == 0 )); then

				Menu_Main_Drive_Manager

			elif (( $TARGETMENUID == 1 )); then

				Menu_Drive_Manager_Edit_Drive

			elif (( $TARGETMENUID == 2 )); then

				Menu_Format

			elif (( $TARGETMENUID == 3 )); then

				Menu_Add_Network_Drive

			fi

		done

	fi
	#-----------------------------------------------------------------------------------
	# Start Services
	(( $SERVICE_CONTROL )) && /DietPi/dietpi/dietpi-services start
	#-----------------------------------------------------------------------------------
	exit $EXIT_CODE
	#-----------------------------------------------------------------------------------
}
